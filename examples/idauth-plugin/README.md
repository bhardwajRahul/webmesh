# ID Based Authentication Plugin

This plugin allows you to authenticate users based on an ID derived from their public key.
To get any use out of this plugin, you generally want to use persistent identities, such as those saved to this directory.

Read the annotations in the `docker-compose.yaml` file to see how the plugin and client-side authentication is configured.

# Generating Keys

Webmesh keys can be generated easily in one of two ways.

- Run the `webmesh-node` as you normally would, but with specifying a `--wireguard.key-file` argument to save the generated key to a file.
- Use the `wmctl` command line tool to generate a key-pair and save it to a file.

The `wmctl` utility has commands almost verbatim to the `wg genkey` and `wg pubkey` commands, but with the addition of a `keyid` command.

```bash
# Generate a key-pair
wmctl genkey > priv.key

# Generate the public key from the private key
wmctl pubkey < priv.key > pub.key

# Read the ID from a public or private key
wmctl keyid < pub.key
wmctl keyid < priv.key
```

# How it Works

Webmesh keys are not typical WireGuard keys.
WireGuard private and public keys are 32 bytes long, and are generated by the `wg genkey` and `wg pubkey` commands.
Webmesh private keys are ed25519 key-pairs that are 64 bytes long with 32 byte long public keys.
The private key consists of the 32 byte private key, with the 32 byte public key at the end.
WireGuard keys are derived from the ed25519 key-pair on each side of the webmesh connection, but are not the same.

This authentication method is inspired (and largely based upon) the identity protocol used in libp2p.
The reason we maintain the full 64 byte private key is to maintain compatibility with the libp2p identity libraries and protocols.
The full specification for how ID derivation works can be found [here](https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md).
The short version is that the ID is the base58 encoding of the "identity" [multihash](https://github.com/multiformats/multihash) of the public key.
The public key is able to be extracted from the ID by decoding the base58 string and extracting the public key from the multihash.

From there, an approach similar to the TOTP algorithm is used to generate expected signatures for a given ID.
The client authenticates by signing a message with their ID and the current timestamp truncated to the nearest 30 seconds.
The server then checks if the signature matches the expected signature for the given ID and timestamp.
If it does, the client is authenticated.
